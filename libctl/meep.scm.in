; Copyright (C) 2003 Massachusetts Institute of Technology
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ****************************************************************

; Get the number of arguments to a function p.  However, some
; older versions of Guile (e.g. 1.2) do not support the 'arity
; property, and procedure-property just returns false.  In
; this case, we assume that the procedure returns 1 argument,
; as this is the most useful default for our purposes.  Sigh.

(define (procedure-num-args p) 
  (let ((arity (procedure-property p 'arity)))
    (if arity (car arity) 1)))

; ****************************************************************

(define-class material-type no-parent)

(define-class polarizability no-parent
  (define-property omega no-default 'number)
  (define-property gamma no-default 'number)
  (define-property delta-epsilon 1.0 'number)
  (define-property energy-saturation 0.0 'number))

(define-class dielectric material-type
  (define-property epsilon no-default 'number)
  (define-property polarizations '() (make-list-type 'polarizability))
  (define-property n2 0 'number)
)

(define-class perfect-metal material-type)

; arbitrary material(x)
(define-class material-function material-type
  (define-property material-func no-default 'function
    (lambda (p) (= 1 (procedure-num-args p)))))

(define (index n) (epsilon (* n n))) ; convenient substitute for epsilon

; use the solid geometry classes, variables, etcetera in libgeom:
; (one specifications file can include another specifications file)
(include "@LIBCTL_DIR@/utils/geom.scm")

(if (defined? 'meep-component-Ex) (include "meep-enums.scm"))

(set-param! ensure-periodicity false) ; this makes less sense for FDTD
(define CYLINDRICAL -2) ; special value of dimensions for cylindrical coords

; ****************************************************************
; Add some predefined variables, for convenience:

(define vacuum (make dielectric (epsilon 1.0)))
(define air vacuum)
(define metal (make perfect-metal))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

(set! default-material vacuum)

(define pi (* 4.0 (atan 1.0)))

; ****************************************************************
; some utilities

(define (volume cen sz)
  (new-meep-geometric-volume 
   (vector3- cen (vector3-scale 0.5 sz))
   (vector3+ cen (vector3-scale 0.5 sz))))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

; display a comma-delimited list of values, prefixed by the data-name
; and the run index, with data a list of values.
(define-param run-index 0)
(define (display-run-data data-name data)
  (print data-name run-index ":")
  (map (lambda (v) (print ", " v)) data)
  (print "\n"))

; display a list of data arrays (all required to be of same length)
; as comma-separated values, prefixed with name (and the run index).
(define (display-csv name . ds)
  (if (not (null? ds))
      (apply
       map
       (cons 
	(lambda (. vs) (display-run-data name vs))
	ds))))

; ****************************************************************
; Setting up the structure

(define-class symmetry no-parent
  (define-property direction no-default 'integer)
  (define-property phase 1.0 'cnumber))
(define-class rotate2-sym symmetry)
(define-class rotate4-sym symmetry)
(define-class mirror-sym symmetry)

(define-class pml no-parent
  (define-property thickness no-default 'number)
  (define-property direction -1 'integer)
  (define-property side -1 'integer)
  (define-property strength 1.0 'number))

(export-type (make-list-type 'symmetry))
(export-type (make-list-type 'pml))

(define-param symmetries '())
(define-param pml-layers '())
(define-param num-chunks 0)
(define-param Courant 0.5)

(define structure '())

(define (init-structure)
  (set! structure (make-structure 
		   dimensions
		   (object-property-value geometry-lattice 'size)
		   resolution
		   geometry default-material
		   pml-layers symmetries num-chunks Courant)))

; ****************************************************************
; Adding sources

(define-class src-time no-parent)
(define-class continuous-src src-time
  (define-property frequency no-default 'number)
  (define-property start-time 0 'number)
  (define-property end-time infinity 'number)
  (define-property width 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-continuous-src-time 
       (object-property-value o 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)
       (object-property-value o 'cutoff)))))
(define-class gaussian-src src-time
  (define-property frequency no-default 'number)
  (define-property width no-default 'number)
  (define-property start-time 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-gaussian-src-time
       (object-property-value o 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (+ (object-property-value o 'start-time)
	  (* 2 (object-property-value o 'width) 
	     (object-property-value o 'cutoff)))))))
(define-class custom-src src-time
  (define-property src-func no-default 'function)
  (define-property start-time (- infinity) 'number)
  (define-property end-time infinity 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-custom-src-time 
       (object-property-value o 'src-function)
       (object-property-value o 'src-function)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)))))

(define-class src-vol no-parent
  (define-property src no-default 'src-time)
  (define-property component no-default 'integer)
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property amplitude 1.0 'cnumber)
  (define-property amp-func '() 'SCM))

; list of sources added by init-fields (below)
(define-param sources '())

(define (add-source s f) ; add source s to fields f
  (let ((A (object-property-value s 'amp-func))
	(cen (object-property-value s 'center))
	(sz (object-property-value s 'size)))
    (if (null? A)
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (object-property-value (object-property-value s 'src) 'swigval)
	 (volume cen sz)
	 (object-property-value s 'amplitude))
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (volume cen sz)
	 A (object-property-value s 'amplitude)))))

; ****************************************************************
; Flux spectra

(define-class flux-region no-parent
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property direction -1 'integer)
  (define-property weight 1.0 'cnumber))

(define (do-flux fmin fmax nfreq . fluxes)
  (define gvl '()) ; geometric_volume_list of flux regions
  (map (lambda (f)
	 (let* ((gv (volume (object-property-value f 'center)
			   (object-property-value f 'size)))
		(d0 (object-property-value f 'direction))
		(d (if (negative? d0)
		       (meep-geometric-volume-normal-direction gv)
		       d0))
		(c (meep-direction-component Sx d)))
	   (set! gvl
		 (new-geometric-volume-list
		  (volume (object-property-value f 'center)
			  (object-property-value f 'size))
		  c
		  (object-property-value f 'weight)
		  gvl))))
       fluxes)
  (meep-fields-add-dft-flux gvl fmin fmax nfreq))

(define (scale-flux-fields s f)
  (meep-dft-flux-scale-dfts f s))

(define (get-flux-freqs f)
  (arith-sequence
   (meep-dft-flux-freq-min-get f)
   (meep-dft-flux-dfreq-get f)
   (meep-dft-flux-Nfreq-get f)))

(export-type (make-list-type 'number))
(define (get-fluxes f)
  (dft-flux-flux f))

; ****************************************************************
; Setting up the fields

(define-param m 0)
(define-param real-fields? false)
(define-param k (vector3 0 0 0))

(define fields '())

(define init-fields-hooks '()) ; list of thunks to execute after init-fields
(define (init-fields)
  (if (null? structure) (init-structure))
  (if (= dimensions CYLINDRICAL)
      (set! fields (new-meep-fields structure m))
      (set! fields (new-meep-fields structure)))
  (if verbose? (meep-fields-verbose fields))
  (if real-fields? (meep-fields-use-real-fields fields))
  (meep-fields-use-bloch fields k)
  (map (lambda (s) (add-source s fields)) sources)
  (map (lambda (thunk) (thunk)) init-fields-hooks))

(define (meep-time) 
  (if (null? fields) (init-fields)) 
  (meep-fields-time fields))

(define (get-field-point c pt)
  (meep-fields-get-field fields c pt))

(define (get-epsilon-point pt)
  (meep-fields-get-eps fields pt))

(define (restart-fields)
  (meep-fields-t-set fields 0)
  (meep-fields-zero-fields fields))

; ****************************************************************
; Output functions (can only be called after init-fields).

(define-param filename-prefix "")
(define (get-filename-prefix)
  (if (and (not (null? include-files))
	   (not (eq? filename-prefix false))
           (string-null? filename-prefix))
      (string-append
       (strip-suffix ".scm"
        (strip-suffix ".ctl" (cdr (split-pathname (car include-files))))))
      filename-prefix))

; Use output directory instead of outputting in same directory;
; uses init-fields-hooks to handle fields not yet initted.
(define (use-output-directory . dname_)
  (let ((dname (if (null? dname_)
		   (string-append (get-filename-prefix "-out"))
		   (car dname_))))
    (let ((hook
	   (let ((trashed? false)) ; only trash output directory once per run
	     (lambda ()
	       (print "Meep: using output directory \"" dname "\"\n")
	       (meep-fields-set-output-directory fields dname)
	       (if (not trashed?) (meep-trash-output-directory dname))
	       (set! trashed? true)))))
      (set! init-fields-hooks (cons hook init-fields-hooks))
      (if (not (null? fields)) (hook))
      (set! filename-prefix false)
      dname)))

; output functions can be either thunks (the common case), or
; can take a "to-do" argument that is currently either 'output
; or 'cleanup (so that they can clean up at the end of a run).
(define (eval-output-func func to-do)
  (if (= 0 (procedure-num-args func))
      (if (eq? to-do 'output) (func))
      (func to-do)))

(define-param output-volume '()) ; region to output; NULL for everywhere

(define output-append-h5 '()) ; h5 file to append data to (NULL if none)

(define (output-component c . h5file)
  (if (null? fields) (error "init-fields is required before output-component"))
  (meep-fields-output-hdf5 
   fields c 
   (if (null? output-volume)
       (meep-volume-surroundings (meep-fields-v-get fields))
       output-volume)
   (if (null? h5file) output-append-h5 (car h5file)) 
   (and (null? h5file) (not (null? output-append-h5)))
   false 
   (get-filename-prefix)))

(define (output-components fname . cs)
  (if (null? fields) (error "init-fields is required before output-component"))
  (let ((f 
	 (if (null? output-append-h5)
	     (list (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
					    (get-filename-prefix) true))
	     '())))
    (map (lambda (c) (apply output-component (cons c f))) cs)
    (meep-h5file-close f)))

; convenience functions, similar to MPB:
(define (output-epsilon) (output-component Dielectric))
(define (output-hpwr) (output-component H-EnergyDensity))
(define (output-dpwr) (output-component D-EnergyDensity))
(define (output-tot-pwr) (output-component EnergyDensity))
(defmacro-public define-output-field (name cp CP)
  `(begin
     (define (,(symbol-append 'output- cp))
       (output-components ,name
			  ,(symbol-append CP 'x)
			  ,(symbol-append CP 'y)
			  ,(symbol-append CP 'z)
			  ,(symbol-append CP 'r) ,(symbol-append CP 'p)))
     (define (,(symbol-append 'output- cp '-x))
       (output-component ,(symbol-append CP 'x)))
     (define (,(symbol-append 'output- cp '-y))
       (output-component ,(symbol-append CP 'y)))
     (define (,(symbol-append 'output- cp '-z))
       (output-component ,(symbol-append CP 'z)))
     (define (,(symbol-append 'output- cp '-r))
       (output-component ,(symbol-append CP 'r)))
     (define (,(symbol-append 'output- cp '-p))
       (output-component ,(symbol-append CP 'p)))))
(define-output-field "h" hfield H)
(define-output-field "e" efield E)
(define-output-field "d" dfield D)
(define-output-field "s" poynting S)

; change output-volume for a few output-funcs to gv
(define (in-volume gv . output-funcs)
  (lambda (to-do)
    (let ((gv-save output-volume))
      (set! output-volume gv)
      (map (lambda (f) (eval-output-func f to-do)) output-funcs)
      (set! output-volume gv-save))))

; Meep supports outputting d+1 dimensional HDF5 files where the last
; dimension is time.
(define (to-appended fname . output-funcs)
  (if (null? fields) (init-fields))
  (let ((h5 (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
				     (get-filename-prefix))))
    (lambda (to-do)
      (let ((h5save output-append-h5))
	(set! output-append-h5 h5)
	(map (lambda (f) (eval-output-func f to-do)) output-funcs)
	(if (eq? to-do 'cleanup) (meep-h5file-close h5))
	(set! output-append-h5 h5save)))))

; Some convenient wrappers for output functions passed to run:

(define (at-every dT . output-funcs)
  (let ((Tlast (meep-time)))
    (lambda (to-do)
      (let ((T (meep-time)))
	(if (>= T (+ Tlast dT))
	    (begin
	      (map (lambda (f) (eval-output-func f to-do)) output-funcs)
	      (set! Tlast T)))))))

; the user could just call functions, but this functions saves the user
; from having to manually call init-fields
(define (at-beginning . output-funcs)
  (let ((done? false))
    (lambda (to-do)
      (if (not done?)
	  (begin
	    (map (lambda (f) (eval-output-func f to-do)) output-funcs)
	    (set! done? true))))))

; for completeness:
(define (at-end . output-funcs)
  (lambda (to-do)
    (if (eq? to-do 'cleanup)
	(map (lambda (f) (eval-output-func f to-do)) output-funcs))))

; ****************************************************************
; harminv functions for extracting bands, etcetera

(export-type (make-list-type 'cnumber))
(define-param harminv-data '())
(define (collect-harminv c pt)
  (lambda ()
    (set! harminv-data 
	  (cons (get-field-point c pt) harminv-data))))

(export-type (make-list-type 'cvector3)) ; for do-harminv
(define (analyze-harminv fmin fmax maxbands)
  (display-run-data 
   "harminv"
   (list "frequency" "imag. freq." "Q" "|amp|" "amplitude" "error"))
  (let ((bands (do-harminv (reverse harminv-data) fields.dt 
			   fmin fmax maxbands)))
    (map (lambda (b) ; b = vector of (freq, amp, error)
	   (display-run-data 
	    "harminv"
	    (list
	     (real-part (vector3-x b)) ", "
	     (imag-part (vector3-x b)) ", "
	     (/ (real-part (vector3-x b))
		(* -2 (imag-part (vector3-x b)))) ", "
		(magnitude (vector3-y b)) ", "
		(vector3-y b) ", " 
		(vector3-z b) "\n")))
	 bands)
    bands))

; collect + analyze and store in harminv-results
(define harminv-results '())
(define (harminv c pt fmin fmax maxbands)
  (set! harminv-data '())
  (lambda (to-do)
    (if (eq? to-do 'cleanup)
	(set! harminv-results (analyze-harminv fmin fmax maxbands))
	((collect-harminv c pt)))))

; ****************************************************************
; run functions

; display progress from T0 until T, every dt seconds (wall time)
(define (display-progress T0 T dt)
  (let ((t0 (meep-wall-time)) (tlast (meep-wall-time)))
    (lambda ()
      (let ((t (meep-wall-time)))
	(if (>= (- t tlast) dt)
	    (begin
	      (print "Meep progress: " 
		     (- (meep-time) T0) "/" T " = "
		     (/ (- (meep-time) T0) (* 0.01 T)) "% done"
		     " in " (- t t0) "s, " 
		     ( - (* (- t t0) (/ T (- (meep-time) T0)))
			 (- t t0)) "s to go\n")
	      (set! tlast t)))))))

; run until (cond?) is true or, if cond? is a number, until time cond?
; (in Meep units) has elapsed, calling output-funcs at every time step.
(define (run-until cond? . output-funcs)
  (set! interactive? false)
  (if (null? fields) (init-fields))
  (if (number? cond?) ; cond? is a time to run for
      (let ((T0 (meep-time))) ; current Meep time
	(apply run-until (cons (lambda () (>= (meep-time) 
					      (+ T0 cond?)))
			       (cons (display-progress T0 (+ T0 cond?) 2)
				     output-funcs))))
      (begin ; otherwise, cond? is a boolean thunk
	(map (lambda (f) (eval-output-func f 'output)) output-funcs)
	(if (cond?)
	    (begin
	      (map (lambda (f) (eval-output-func f 'cleanup)) output-funcs)
	      (print "run " run-index " finished at t = " (meep-time)
		     " (" (meep-fields-t-get fields) " timesteps)\n")
	      (set! run-index (+ run-index 1)))
	    (begin
	      (meep-fields-step fields)
	      (apply run-until (cons cond? output-funcs)))))))

; run until all sources are finished and cond? is true.  If cond? is a number
; T, run until all sources are finished + a time T.
(define (run-sources+ cond? . output-funcs)
  (if (null? fields) (init-fields))
  (let ((Ts (meep-fields-last-source-time fields)))
  (apply run-until 
	 (cons (if (number? cond?)
		   (+ (- Ts (meep-time)) cond?)
		   (lambda () (and (>= (meep-time) Ts) (cond?))))
	       output-funcs))))

; run until all sources are finished
(define (run-sources . output-funcs)
  (apply run-sources+ (cons 0 output-funcs)))

; ****************************************************************

; Load GNU Readline support, for easier command-line editing support.
; This is not loaded in by default in Guile 1.3.2+ because readline is
; licensed under the GPL, which would have caused Guile to effectively
; be under the GPL itself.  However, since Meep is under the GPL too,
; we can load Readline by default with no problems.

@ACTIVATE_READLINE@  ; command to activate readline is determined by configure

(set! scm-repl-prompt "meep> ")

; ****************************************************************

