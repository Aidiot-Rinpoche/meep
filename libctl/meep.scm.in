; Copyright (C) 2003 Massachusetts Institute of Technology
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ****************************************************************

; Get the number of arguments to a function p.  However, some
; older versions of Guile (e.g. 1.2) do not support the 'arity
; property, and procedure-property just returns false.  In
; this case, we assume that the procedure returns 1 argument,
; as this is the most useful default for our purposes.  Sigh.

(define (procedure-num-args p) 
  (let ((arity (procedure-property p 'arity)))
    (if arity (car arity) 1)))

; ****************************************************************

(define-class material-type no-parent)

(define-class polarizability no-parent
  (define-property omega no-default 'number)
  (define-property gamma no-default 'number)
  (define-property delta-epsilon 1.0 'number)
  (define-property energy-saturation 0.0 'number))

(define-class dielectric material-type
  (define-property epsilon no-default 'number)
  (define-property polarizations '() (make-list-type 'polarizability))
  (define-property n2 0 'number)
)

(define-class perfect-metal material-type)

; arbitrary material(x)
(define-class material-function material-type
  (define-property material-func no-default 'function
    (lambda (p) (= 1 (procedure-num-args p)))))

(define (index n) (epsilon (* n n))) ; convenient substitute for epsilon

; use the solid geometry classes, variables, etcetera in libgeom:
; (one specifications file can include another specifications file)
(include "@LIBCTL_DIR@/utils/geom.scm")

(if (defined? 'meep-component-Ex) (include "meep-enums.scm"))

(set-param! ensure-periodicity false) ; this makes less sense for FDTD
(define CYLINDRICAL -2) ; special value of dimensions for cylindrical coords

; ****************************************************************
; Add some predefined variables, for convenience:

(define vacuum (make dielectric (epsilon 1.0)))
(define air vacuum)
(define metal (make perfect-metal))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

(set! default-material vacuum)

(define pi (* 4.0 (atan 1.0)))

; ****************************************************************
; some utilities

(define (volume cen sz)
  (new-meep-geometric-volume 
   (vector3- cen (vector3-scale 0.5 sz))
   (vector3+ cen (vector3-scale 0.5 sz))))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

; display a comma-delimited list of values, prefixed by the data-name
; and the run index, with data a list of values.
(define-param run-index 0)
(define (display-run-data data-name data)
  (print data-name run-index ":")
  (map (lambda (v) (print ", " v)) data)
  (print "\n"))

; display a list of data arrays (all required to be of same length)
; as comma-separated values, prefixed with name (and the run index).
(define (display-csv name . ds)
  (if (not (null? ds))
      (apply
       map
       (cons 
	(lambda (. vs) (display-run-data name vs))
	ds))))

; ****************************************************************
; Setting up the structure

(define-class symmetry no-parent
  (define-property direction no-default 'integer)
  (define-property phase 1.0 'cnumber))
(define-class rotate2-sym symmetry)
(define-class rotate4-sym symmetry)
(define-class mirror-sym symmetry)

(define-class pml no-parent
  (define-property thickness no-default 'number)
  (define-property direction -1 'integer)
  (define-property side -1 'integer)
  (define-property strength 1.0 'number))

(export-type (make-list-type 'symmetry))
(export-type (make-list-type 'pml))

(define-param symmetries '())
(define-param pml-layers '())
(define-param num-chunks 0)
(define-param Courant 0.5)

(define structure '())

(define (init-structure)
  (set! structure (make-structure 
		   dimensions
		   (object-property-value geometry-lattice 'size)
		   resolution
		   geometry default-material
		   pml-layers symmetries num-chunks Courant)))

; ****************************************************************
; Adding sources

(define-class src-time no-parent)
(define-class continuous-src src-time
  (define-property frequency no-default 'number)
  (define-property start-time 0 'number)
  (define-property end-time infinity 'number)
  (define-property width 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-continuous-src-time 
       (object-property-value o 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)
       (object-property-value o 'cutoff)))))
(define-class gaussian-src src-time
  (define-property frequency no-default 'number)
  (define-property width no-default 'number)
  (define-property start-time 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-gaussian-src-time
       (object-property-value o 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (+ (object-property-value o 'start-time)
	  (* 2 (object-property-value o 'width) 
	     (object-property-value o 'cutoff)))))))
(define-class custom-src src-time
  (define-property src-func no-default 'function)
  (define-property start-time (- infinity) 'number)
  (define-property end-time infinity 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-custom-src-time 
       (object-property-value o 'src-function)
       (object-property-value o 'src-function)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)))))

(define (fwidth df) (width (/ df))) ; to specify frequency width instead

(define-class source no-parent
  (define-property src no-default 'src-time)
  (define-property component no-default 'integer)
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property amplitude 1.0 'cnumber)
  (define-property amp-func '() 'SCM))

; list of sources added by init-fields (below)
(define-param sources '())

(define (add-source s f) ; add source s to fields f
  (let ((A (object-property-value s 'amp-func))
	(cen (object-property-value s 'center))
	(sz (object-property-value s 'size)))
    (if (null? A)
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (object-property-value (object-property-value s 'src) 'swigval)
	 (volume cen sz)
	 (object-property-value s 'amplitude))
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (volume cen sz)
	 A (object-property-value s 'amplitude)))))

; ****************************************************************
; Flux spectra

(define-class flux-region no-parent
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property direction -1 'integer)
  (define-property weight 1.0 'cnumber))

(define (fields-add-flux fields fmin fmax nfreq . fluxes)
  (define gvl '()) ; geometric_volume_list of flux regions
  (map (lambda (f)
	 (let* ((gv (volume (object-property-value f 'center)
			   (object-property-value f 'size)))
		(d0 (object-property-value f 'direction))
		(d (if (negative? d0)
		       (meep-geometric-volume-normal-direction gv)
		       d0))
		(c (meep-direction-component Sx d)))
	   (set! gvl
		 (new-meep-geometric-volume-list
		  (volume (object-property-value f 'center)
			  (object-property-value f 'size))
		  c
		  (object-property-value f 'weight)
		  gvl))))
       fluxes)
  (meep-fields-add-dft-flux fields gvl fmin fmax nfreq))

(define (add-flux fmin fmax nfreq . fluxes)
  (if (null? fields) (init-fields))
  (apply fields-add-flux (append (list fields fmin fmax nfreq) fluxes)))

(define (scale-flux-fields s f)
  (meep-dft-flux-scale-dfts f s))

(define (get-flux-freqs f)
  (arith-sequence
   (meep-dft-flux-freq-min-get f)
   (meep-dft-flux-dfreq-get f)
   (meep-dft-flux-Nfreq-get f)))

(export-type (make-list-type 'number))
(define (get-fluxes f)
  (dft-flux-flux f))

(define (display-fluxes . fluxes)
  (if (not (null? fluxes))
      (apply display-csv
	     (append (list "flux"
			   (get-flux-freqs (car fluxes)))
		     (map get-fluxes fluxes)))))

; ****************************************************************
; Setting up the fields

(define-param m 0)
(define-param real-fields? false)
(define-param k (vector3 0 0 0))

(define fields '())

(define init-fields-hooks '()) ; list of thunks to execute after init-fields
(define (init-fields)
  (if (null? structure) (init-structure))
  (if (= dimensions CYLINDRICAL)
      (set! fields (new-meep-fields structure m))
      (set! fields (new-meep-fields structure)))
  (if verbose? (meep-fields-verbose fields))
  (if real-fields? (meep-fields-use-real-fields fields))
  (meep-fields-use-bloch fields k)
  (map (lambda (s) (add-source s fields)) sources)
  (map (lambda (thunk) (thunk)) init-fields-hooks))

(define (meep-time) 
  (if (null? fields) (init-fields)) 
  (meep-fields-time fields))

(define (get-field-point c pt)
  (meep-fields-get-field fields c pt))

(define (get-epsilon-point pt)
  (meep-fields-get-eps fields pt))

(define (restart-fields)
  (meep-fields-t-set fields 0)
  (meep-fields-zero-fields fields))

; ****************************************************************
; Generic step functions: these are functions which are called
; (potentially) at every time step.  They can either be a thunk
; or they can take one argument, to-do.  to-do is either 'step
; or 'finish, where 'step means to output (or whatever)
; normally, and 'finish is passed once at the end of the run
; (and is used to close files, print summary output, etcetera).

; step functions can be either thunks (the common case), or
; can take a "to-do" argument that is currently either 'step
; or 'finish (so that they can clean up at the end of a run).
(define (eval-step-func func to-do)
  (if (= 0 (procedure-num-args func))
      (if (eq? to-do 'step) (func))
      (func to-do)))
 
; Some convenient wrappers for step functions passed to run.  e.g., these
; can be used to only output at certain times, instead of ata every time step.

(define (combine-step-funcs . step-funcs)
  (lambda (to-do)
    (map (lambda (f) (eval-step-func f to-do)) step-funcs)))

; generic wrapper
(define (when-true-funcs cond? step-funcs)
  (lambda (to-do)
    (if (or (eq? to-do 'finish) (cond?))
	(map (lambda (f) (eval-step-func f to-do)) step-funcs))))

; evaluate step-funcs whenever (cond?) is true.
(define (when-true cond? . step-funcs) (when-true-funcs cond? step-funcs))

; output at an interval of dT (in meep/simulation time).
(define (at-every dT . step-funcs)
  (if (null? fields) (init-fields))
  (let ((Tlast (meep-time)))
    (lambda (to-do)
      (let ((T (meep-time)))
	(if (or (eq? to-do 'finish) (>= T (+ Tlast dT)))
	    (begin
	      (map (lambda (f) (eval-step-func f to-do)) step-funcs)
	      (set! Tlast T)))))))

(define (after-time T . step-funcs)
  (if (null? fields) (init-fields))
  (let ((T0 (meep-time)))
    (when-true-funcs (lambda () (> (meep-time) (+ T0 T))) step-funcs)))

(define (before-time T . step-funcs)
  (if (null? fields) (init-fields))
  (let ((T0 (meep-time)))
    (when-true-funcs (lambda () (<= (meep-time) (+ T0 T))) step-funcs)))

(define (after-sources . step-funcs)
  (if (null? fields) (init-fields))
  (apply after-time
	 (cons (- (meep-fields-last-source-time fields) (meep-time))
	       step-funcs)))

; after sources plus a time T.
(define (after-sources+ T . step-funcs)
  (if (null? fields) (init-fields))
  (apply after-time
	 (cons (- (+ (meep-fields-last-source-time fields) T) (meep-time))
	       step-funcs)))

(define (during-sources . step-funcs)
  (if (null? fields) (init-fields))
  (apply before-time
	 (cons (- (meep-fields-last-source-time fields) (meep-time))
	       step-funcs)))

; the user could just call functions, but this functions saves the user
; from having to manually call init-fields
(define (at-beginning . step-funcs)
  (let ((done? false))
    (lambda (to-do)
      (if (not done?)
	  (begin
	    (map (lambda (f) (eval-step-func f to-do)) step-funcs)
	    (set! done? true))))))

; for completeness (although the user could just do this after running):
(define (at-end . step-funcs)
  (lambda (to-do)
    (if (eq? to-do 'finish)
	(begin
	  (map (lambda (f) (eval-step-func f 'step)) step-funcs)
	  (map (lambda (f) (eval-step-func f 'finish)) step-funcs)))))

; ****************************************************************
; File output functions (can only be called after init-fields).

(define-param filename-prefix "")
(define (get-filename-prefix)
  (if (and (not (null? include-files))
	   (not (eq? filename-prefix false))
           (string-null? filename-prefix))
      (string-append
       (strip-suffix ".scm"
        (strip-suffix ".ctl" (cdr (split-pathname (car include-files))))))
      filename-prefix))

; Use output directory instead of outputting in same directory;
; uses init-fields-hooks to handle fields not yet initted.
(define (use-output-directory . dname_)
  (let ((dname (if (null? dname_)
		   (string-append (get-filename-prefix "-out"))
		   (car dname_))))
    (let ((hook
	   (let ((trashed? false)) ; only trash output directory once per run
	     (lambda ()
	       (print "Meep: using output directory \"" dname "\"\n")
	       (meep-fields-set-output-directory fields dname)
	       (if (not trashed?) (meep-trash-output-directory dname))
	       (set! trashed? true)))))
      (set! init-fields-hooks (cons hook init-fields-hooks))
      (if (not (null? fields)) (hook))
      (set! filename-prefix false)
      dname)))

(define-param output-volume '()) ; region to output; NULL for everywhere

(define output-append-h5 '()) ; h5 file to append data to (NULL if none)

(define (output-component c . h5file)
  (if (null? fields) (error "init-fields is required before output-component"))
  (meep-fields-output-hdf5 
   fields c 
   (if (null? output-volume)
       (meep-volume-surroundings (meep-fields-v-get fields))
       output-volume)
   (if (null? h5file) output-append-h5 (car h5file)) 
   (and (null? h5file) (not (null? output-append-h5)))
   false 
   (get-filename-prefix)))

(define (output-components fname . cs)
  (if (null? fields) (error "init-fields is required before output-component"))
  (let ((f 
	 (if (null? output-append-h5)
	     (list (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
					    (get-filename-prefix) true))
	     '())))
    (map (lambda (c) (apply output-component (cons c f))) cs)
    (delete-meep-h5file f)))

; convenience functions, similar to MPB:
(define (output-epsilon) (output-component Dielectric))
(define (output-hpwr) (output-component H-EnergyDensity))
(define (output-dpwr) (output-component D-EnergyDensity))
(define (output-tot-pwr) (output-component EnergyDensity))
(defmacro-public define-output-field (name cp CP)
  `(begin
     (define (,(symbol-append 'output- cp))
       (output-components ,name
			  ,(symbol-append CP 'x)
			  ,(symbol-append CP 'y)
			  ,(symbol-append CP 'z)
			  ,(symbol-append CP 'r) ,(symbol-append CP 'p)))
     (define (,(symbol-append 'output- cp '-x))
       (output-component ,(symbol-append CP 'x)))
     (define (,(symbol-append 'output- cp '-y))
       (output-component ,(symbol-append CP 'y)))
     (define (,(symbol-append 'output- cp '-z))
       (output-component ,(symbol-append CP 'z)))
     (define (,(symbol-append 'output- cp '-r))
       (output-component ,(symbol-append CP 'r)))
     (define (,(symbol-append 'output- cp '-p))
       (output-component ,(symbol-append CP 'p)))))
(define-output-field "h" hfield H)
(define-output-field "e" efield E)
(define-output-field "d" dfield D)
(define-output-field "s" poynting S)

; change output-volume for a few step-funcs to gv
(define (in-volume gv . step-funcs)
  (lambda (to-do)
    (let ((gv-save output-volume))
      (set! output-volume gv)
      (map (lambda (f) (eval-step-func f to-do)) step-funcs)
      (set! output-volume gv-save))))
(define (in-point pt . step-funcs)
  (apply in-volume (cons (volume pt (vector3 0)) step-funcs)))

; Meep supports outputting d+1 dimensional HDF5 files where the last
; dimension is time.
(define (to-appended fname . step-funcs)
  (if (null? fields) (init-fields))
  (let ((h5 (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
				     (get-filename-prefix))))
    (lambda (to-do)
      (let ((h5save output-append-h5))
	(set! output-append-h5 h5)
	(map (lambda (f) (eval-step-func f to-do)) step-funcs)
	(if (eq? to-do 'finish) (delete-meep-h5file h5))
	(set! output-append-h5 h5save)))))

; ****************************************************************
; harminv functions for extracting bands, etcetera

 ; for do-harminv
(export-type (make-list-type 'cnumber))
(export-type (make-list-type 'cvector3))

; generic data-collection function
(defmacro-public collect-harminv (data data-dt)
  `(lambda (c pt)
     (set! ,data '())
     (let ((t0 0))
       (lambda () 
	 (set! ,data-dt (- (meep-time) t0))
	 (set! t0 (meep-time))
	 (set! ,data (cons (get-field-point c pt) ,data))))))

; do-harminv returns a (freq, amp, err) vector3; define accessor functions:
(define harminv-freq vector3-x)
(define (harminv-freq-re b) (real-part (vector3-x b)))
(define (harminv-freq-im b) (imag-part (vector3-x b)))
(define (harminv-Q b) (/ (harminv-freq-re b)
			 (* -2 (harminv-freq-im b))))
(define harminv-amp vector3-y)
(define harminv-err vector3-z)

(define (analyze-harminv data fmin fmax maxbands . dt)
  (display-run-data 
   "harminv"
   (list "frequency" "imag. freq." "Q" "|amp|" "amplitude" "error"))
  (let ((bands (do-harminv data
			   (if (null? dt)
			       (meep-fields-dt-get fields)
			       (car dt))
			   fmin fmax maxbands)))
    (map (lambda (b) ; b = vector of (freq, amp, error)
	   (display-run-data 
	    "harminv"
	    (list
	     (harminv-freq-re b)
	     (harminv-freq-im b)
	     (harminv-Q b)
	     (magnitude (harminv-amp b))
	     (harminv-amp b)
	     (harminv-err b))))
	 bands)
    bands))

; collect in harminv-data + analyze and store in harminv-results
(define harminv-data '())
(define harminv-data-dt 0)
(define harminv-results '())
(define (harminv c pt fmin fmax . maxbands)
  (set! harminv-data '())
  (combine-step-funcs
   (at-end
    (lambda ()
      (set! harminv-data (reverse harminv-data)) ; put in correct order
      (set! harminv-results 
	    (analyze-harminv harminv-data fmin fmax
			     (if (null? maxbands) 100 (car maxbands))
			     harminv-data-dt))))
   ((collect-harminv harminv-data harminv-data-dt) c pt)))

; ****************************************************************
; run functions

; default time interval (seconds) between progress printouts
(define-param progress-interval 4)

; display progress from T0 until T, every dt seconds (wall time)
(define (display-progress T0 T dt)
  (let ((t0 (meep-wall-time)) (tlast (meep-wall-time)))
    (lambda ()
      (let ((t (meep-wall-time)))
	(if (>= (- t tlast) dt)
	    (begin
	      (print "Meep progress: " 
		     (- (meep-time) T0) "/" T " = "
		     (/ (- (meep-time) T0) (* 0.01 T)) "% done"
		     " in " (- t t0) "s, " 
		     ( - (* (- t t0) (/ T (- (meep-time) T0)))
			 (- t t0)) "s to go\n")
	      (set! tlast t)))))))

; run until (cond?) is true or, if cond? is a number, until time cond?
; (in Meep units) has elapsed, calling step-funcs at every time step.
(define (run-until cond? . step-funcs)
  (set! interactive? false)
  (if (null? fields) (init-fields))
  (if (number? cond?) ; cond? is a time to run for
      (let ((T0 (meep-time))) ; current Meep time
	(apply run-until (cons (lambda () (>= (meep-time) 
					      (+ T0 cond?)))
			       (cons (display-progress T0 (+ T0 cond?) 
						       progress-interval)
				     step-funcs))))
      (begin ; otherwise, cond? is a boolean thunk
	(map (lambda (f) (eval-step-func f 'step)) step-funcs)
	(if (cond?)
	    (begin
	      (map (lambda (f) (eval-step-func f 'finish)) step-funcs)
	      (print "run " run-index " finished at t = " (meep-time)
		     " (" (meep-fields-t-get fields) " timesteps)\n")
	      (set! run-index (+ run-index 1)))
	    (begin
	      (meep-fields-step fields)
	      (apply run-until (cons cond? step-funcs)))))))

; run until all sources are finished and cond? is true.  If cond? is a number
; T, run until all sources are finished + a time T.
(define (run-sources+ cond? . step-funcs)
  (if (null? fields) (init-fields))
  (let ((Ts (meep-fields-last-source-time fields)))
  (apply run-until 
	 (cons (if (number? cond?)
		   (+ (- Ts (meep-time)) cond?)
		   (lambda () (and (>= (meep-time) Ts) (cond?))))
	       step-funcs))))

; run until all sources are finished
(define (run-sources . step-funcs)
  (apply run-sources+ (cons 0 step-funcs)))

; ****************************************************************

; Load GNU Readline support, for easier command-line editing support.
; This is not loaded in by default in Guile 1.3.2+ because readline is
; licensed under the GPL, which would have caused Guile to effectively
; be under the GPL itself.  However, since Meep is under the GPL too,
; we can load Readline by default with no problems.

@ACTIVATE_READLINE@  ; command to activate readline is determined by configure

(set! scm-repl-prompt "meep> ")

; ****************************************************************

