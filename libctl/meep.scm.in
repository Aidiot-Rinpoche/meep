; Copyright (C) 2003 Massachusetts Institute of Technology
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ****************************************************************

; Get the number of arguments to a function p.  However, some
; older versions of Guile (e.g. 1.2) do not support the 'arity
; property, and procedure-property just returns false.  In
; this case, we assume that the procedure returns 1 argument,
; as this is the most useful default for our purposes.  Sigh.

(define (procedure-num-args p) 
  (let ((arity (procedure-property p 'arity)))
    (if arity (car arity) 1)))

; ****************************************************************

(define-class material-type no-parent)

(define-class polarizability no-parent
  (define-property omega no-default 'number)
  (define-property gamma no-default 'number)
  (define-property delta-epsilon 1.0 'number)
  (define-property energy-saturation 0.0 'number))

(define-class dielectric material-type
  (define-property epsilon no-default 'number)
  (define-property polarizations '() (make-list-type 'polarizability))
  (define-property n2 0 'number)
)

(define-class perfect-metal material-type)

; arbitrary material(x)
(define-class material-function material-type
  (define-property material-func no-default 'function
    (lambda (p) (= 1 (procedure-num-args p)))))

(define (index n) (epsilon (* n n))) ; convenient substitute for epsilon

; use the solid geometry classes, variables, etcetera in libgeom:
; (one specifications file can include another specifications file)
(include "@LIBCTL_DIR@/utils/geom.scm")

(if (defined? 'meep-component-Ex) (include "meep-enums.scm"))

(set-param! ensure-periodicity false) ; this makes less sense for FDTD
(define CYLINDRICAL -2) ; special value of dimensions for cylindrical coords

; ****************************************************************
; Add some predefined variables, for convenience:

(define vacuum (make dielectric (epsilon 1.0)))
(define air vacuum)
(define metal (make perfect-metal))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

(set! default-material vacuum)

(define pi (* 4.0 (atan 1.0)))

; ****************************************************************
; some utilities

(define (vector3->vec v)
  (cond
   ((= dimensions 1) (new-meep-vec (vector3-z v)))
   ((= dimensions 2) (new-meep-vec (vector3-x v) (vector3-y v)))
   ((= dimensions 3) (new-meep-vec (vector3-x v) (vector3-y v) (vector3-z v)))
   ((= dimensions CYLINDRICAL) (meep-veccyl (vector3-x v) (vector3-y v)))))

(define (vec->vector3 v) (vec2vector3 v))

(define (volume cen sz)
  (new-meep-geometric-volume 
   (vector3->vec (vector3- cen (vector3-scale 0.5 sz)))
   (vector3->vec (vector3+ cen (vector3-scale 0.5 sz)))))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

; ****************************************************************
; Setting up the structure

(define-class symmetry no-parent
  (define-property direction no-default 'integer)
  (define-property phase 1.0 'cnumber))
(define-class rotate2-sym symmetry)
(define-class rotate4-sym symmetry)
(define-class mirror-sym symmetry)

(define-class pml no-parent
  (define-property thickness no-default 'number)
  (define-property direction -1 'integer)
  (define-property side -1 'integer)
  (define-property strength 1.0 'number))

(define-input-var symmetries '() (make-list-type 'symmetry))
(define-input-var pml-layers '() (make-list-type 'pml))
(define-input-var num-chunks 0 'integer)
(define-input-var Courant 0.5 'number)

(define structure '())

(define (init-structure)
  (set! structure (make-structure 
		   dimensions
		   (object-property-value geometry-lattice 'size)
		   resolution
		   geometry default-material
		   pml-layers symmetries num-chunks Courant)))

; ****************************************************************
; Adding sources

(define-class src-time no-parent)
(define-class continuous-src src-time
  (define-property frequency no-default 'number)
  (define-property start-time 0 'number)
  (define-property end-time infinity 'number)
  (define-property width 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-continuous-src-time 
       (object-property-value o 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)
       (object-property-value o 'cutoff)))))
(define-class gaussian-src src-time
  (define-property frequency no-default 'number)
  (define-property width no-default 'number)
  (define-property start-time 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-gaussian-src-time
       (object-property-value 'frequency)
       (object-property-value o 'width)
       (object-property-value o 'start-time)
       (+ (object-property-value o 'start-time)
	  (* 2 (object-property-value o 'width) 
	     (object-property-value o 'cutoff)))))))
(define-class custom-src src-time
  (define-property src-func no-default 'function)
  (define-property start-time (- infinity) 'number)
  (define-property end-time infinity 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (new-meep-custom-src-time 
       (object-property-value 'src-function)
       (object-property-value 'src-function)
       (object-property-value o 'start-time)
       (object-property-value o 'end-time)))))

(define-class src-vol no-parent
  (define-property src no-default 'src-time)
  (define-property component no-default 'integer)
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property amplitude 1.0 'cnumber)
  (define-property amp-func '() 'function))

; list of sources added by init-fields (below)
(define-param sources '())

(define (add-source s f) ; add source s to fields f
  (let ((A (object-property-value s 'amp-func))
	(cen (object-property-value s 'center))
	(sz (object-property-value s 'size)))
    (if (null? A)
	(meep-fields-add-volume-src
	 (object-property-value s 'component)
	 (object-property-value (object-property-value s 'src) 'swigval)
	 (volume cen sz)
	 (object-property-value s 'amplitude))
	(meep-fields-add-volume-src
	 (object-property-value s 'component)
	 (volume cen sz)
	 A (object-property-value s 'amplitude)))))

; ****************************************************************
; Flux spectra

(define-class flux-region no-parent
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property direction -1 'integer)
  (define-property weight 1.0 'cnumber))

(define (do-flux fmin fmax nfreq . fluxes)
  (define gvl '()) ; geometric_volume_list of flux regions
  (map (lambda (f)
	 (let* ((gv (volume (object-property-value f 'center)
			   (object-property-value f 'size)))
		(d0 (object-property-value f 'direction))
		(d (if (negative? d0)
		       (meep-geometric-volume-normal-direction gv)
		       d0))
		(c (meep-direction-component Sx d)))
	   (set! gvl
		 (new-geometric-volume-list
		  (volume (object-property-value f 'center)
			  (object-property-value f 'size))
		  c
		  (object-property-value f 'weight)
		  gvl))))
       fluxes)
  (meep-fields-add-dft-flux gvl fmin fmax nfreq))

(define (scale-flux-fields s f)
  (meep-dft-flux-scale-dfts f s))

(define (get-flux-freqs f)
  (arith-sequence
   (meep-dft-flux-freq-min-get f)
   (meep-dft-flux-dfreq-get f)
   (meep-dft-flux-Nfreq-get f)))

(set! exported-type-list (cons (make-list-type 'number) exported-type-list))
(define (get-fluxes f)
  (dft-flux-flux f))

; display fluxes as comma-delimited text, assuming all of the
; fluxes use the same frequency list
(define (display-fluxes . fs)
  (if (not (null? fs))
      (apply
       map
       (cons
	(lambda (freq . fluxes)
	  (print "flux:, " freq)
	  (map (lambda (f) (print ", " f)) fluxes)
	  (print "\n"))
	(cons
	 (get-flux-freqs (car fs))
	 (map get-fluxes fs))))))

; ****************************************************************
; Setting up the fields

(define-param m 0)
(define-param real-fields? false)
(define-param k (vector3 0 0 0))

(define fields '())

(define init-fields-hooks '()) ; list of thunks to execute after init-fields
(define (init-fields)
  (if (null? structure) (init-structure))
  (if (= dimensions CYLINDRICAL)
      (set! fields (new-meep-fields structure m))
      (set! fields (new-meep-fields structure)))
  (if verbose? (meep-fields-verbose fields))
  (if real-fields? (meep-fields-use-real-fields fields))
  (meep-fields-use-bloch fields (vector3->vec k))
  (map (lambda (s) (add-source s fields)) sources)
  (map (lambda (thunk) (thunk)) init-fields-hooks))

(define (meep-time) (meep-fields-time fields))

(define (get-field-point c pt)
  (meep-fields-get-field fields c (vector3->vec pt)))

(define (get-epsilon-point pt)
  (meep-fields-get-eps fields (vector3->vec pt)))

(define (restart-fields)
  (meep-fields-t-set fields 0)
  (meep-fields-zero-fields fields))

; ****************************************************************
; Output functions (can only be called after init-fields).

(define-param filename-prefix "")
(define (get-filename-prefix)
  (if (and (not (null? include-files))
           (string-null? filename-prefix))
      (string-append
       (strip-suffix ".scm"
        (strip-suffix ".ctl" (cdr (split-pathname (car include-files)))))
       "-")
      filename-prefix))

; Use output directory instead of outputting in same directory;
; uses init-fields-hooks to handle fields not yet initted.
(define (use-output-directory . dname_)
  (let ((dname (if (null? dname_)
		   (string-append (get-filename-prefix "-out"))
		   (car dname_))))
    (let ((hook
	   (let ((trashed? false)) ; only trash output directory once per run
	     (lambda ()
	       (print "Meep: using output directory \"" dname "\"\n")
	       (meep-fields-set-output-directory fields dname)
	       (if (not trashed?) (meep-trash-output-directory dname))
	       (set! trashed? true)))))
      (set! init-fields-hooks (cons hook init-fields-hooks))
      (if (not (null? fields)) (hook))
      dname)))

(define-param output-volume '()) ; region to output; NULL for everywhere

(define (output-component c . h5file)
  (if (null? fields) (error "init-fields is required before output-component"))
  (meep-fields-output-hdf5 
   fields c 
   (if (null? output-volume)
       (meep-volume-surroundings (meep-fields-v-get fields))
       output-volume)
   (if (null? h5file) '() (car h5file)) false false 
   (get-filename-prefix)))

(define (output-components fname . cs)
  (if (null? fields) (error "init-fields is required before output-component"))
  (let ((f (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
				    (get-filename-prefix) true)))
    (map (lambda (c) (output-component c f)) cs)
    (meep-h5file-close f)))

; convenience functions, similar to MPB:
(define (output-epsilon) (output-component Dielectric))
(define (output-hpwr) (output-component H-EnergyDensity))
(define (output-dpwr) (output-component D-EnergyDensity))
(define (output-tot-pwr) (output-component EnergyDensity))
(defmacro-public define-output-field (name cp CP)
  `(begin
     (define (,(symbol-append 'output- cp))
       (output-components ,name
			  ,(symbol-append CP 'x)
			  ,(symbol-append CP 'y)
			  ,(symbol-append CP 'z)
			  ,(symbol-append CP 'r) ,(symbol-append CP 'p)))
     (define (,(symbol-append 'output- cp '-x))
       (output-component ,(symbol-append CP 'x)))
     (define (,(symbol-append 'output- cp '-y))
       (output-component ,(symbol-append CP 'y)))
     (define (,(symbol-append 'output- cp '-z))
       (output-component ,(symbol-append CP 'z)))
     (define (,(symbol-append 'output- cp '-r))
       (output-component ,(symbol-append CP 'r)))
     (define (,(symbol-append 'output- cp '-p))
       (output-component ,(symbol-append CP 'p)))))
(define-output-field "h" hfield H)
(define-output-field "e" efield E)
(define-output-field "d" dfield D)
(define-output-field "s" poynting S)

; Some convenient wrappers for output functions passed to run:

(define (at-every dT . output-funcs)
  (let ((Tlast (meep-time)))
    (lambda ()
      (let ((T (meep-time)))
	(if (>= T (+ Tlast dT))
	    (begin
	      (map (lambda (f) (f)) output-funcs)
	      (set! Tlast T)))))))

; the user could just call functions, but this functions saves the user
; from having to manually call init-fields
(define (at-beginning . output-funcs)
  (let ((done? false))
    (lambda ()
      (if (not done?)
	  (begin
	    (map (lambda (f) (f)) output-funcs)
	    (set! done? true))))))

; ****************************************************************
; harminv functions for extracting bands, etcetera

(define-input-var harminv-data '() (make-list-type 'cnumber))
(define (collect-harminv c pt)
  (lambda ()
    (set! harminv-data 
	  (cons (get-field-point c pt) harminv-data))))

(define-output-var harminv-results (make-list-type 'cvector3))
(define (analyze-harminv fmin fmax maxbands)
  (print "harminv:, frequency, imag. freq., Q, |amp|, amplitude, error\n")
  (let ((bands (do-harminv (reverse harminv-data) fields.dt 
			   fmin fmax maxbands)))
    (map (lambda (b) ; b = vector of (freq, amp, error)
	   (print "harminv:, " 
		  (real-part (vector3-x b)) ", "
		  (imag-part (vector3-x b)) ", "
		  (/ (real-part (vector3-x b))
		     (* -2 (imag-part (vector3-x b)))) ", "
		  (magnitude (vector3-y b)) ", "
		  (vector3-y b) ", " 
		  (vector3-z b) "\n"))
	 bands)
    (set! harminv-results bands)
    bands))

; ****************************************************************
; run functions

; display progress from T0 until T, every dt seconds (wall time)
(define (display-progress T0 T dt)
  (let ((t0 (meep-wall-time)) (tlast (meep-wall-time)))
    (lambda ()
      (let ((t (meep-wall-time)))
	(if (>= (- t tlast) dt)
	    (begin
	      (print "Meep progress: " 
		     (- (meep-time) T0) "/" T " = "
		     (/ (- (meep-time) T0) (* 0.01 T)) "% done"
		     " in " (- t t0) "s, " 
		     ( - (* (- t t0) (/ T (- (meep-time) T0)))
			 t) "s to go\n")
	      (set! tlast t)))))))

; run until (cond?) is true or, if cond? is a number, until time cond?
; (in Meep units) has elapsed, calling output-funcs at every time step.
(define (run-until cond? . output-funcs)
  (if (null? fields) (init-fields))
  (if (number? cond?) ; cond? is a time to run for
      (let ((T0 (meep-time))) ; current Meep time
	(apply run-until (cons (lambda () (>= (meep-time) 
					      (+ T0 cond?)))
			       (cons (display-progress T0 (+ T0 cond?) 5)
				     output-funcs))))
      (begin ; otherwise, cond? is a boolean thunk
	(map (lambda (f) (f)) output-funcs)
	(if (not (cond?))
	    (begin
	      (meep-fields-step fields)
	      (apply run-until (cons cond? output-funcs)))))))

; run until all sources are finished
(define (run-sources . output-funcs)
  (if (null? fields) (init-fields))
  (apply run-until (cons (meep-fields-last-source-time fields) output-funcs)))

; ****************************************************************

; Load GNU Readline support, for easier command-line editing support.
; This is not loaded in by default in Guile 1.3.2+ because readline is
; licensed under the GPL, which would have caused Guile to effectively
; be under the GPL itself.  However, since Meep is under the GPL too,
; we can load Readline by default with no problems.

@ACTIVATE_READLINE@  ; command to activate readline is determined by configure

(set! scm-repl-prompt "meep> ")

; ****************************************************************

