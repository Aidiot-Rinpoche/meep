; Copyright (C) 2005-2007 Massachusetts Institute of Technology
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ****************************************************************

; Get the number of arguments to a function p.  However, some
; older versions of Guile (e.g. 1.2) do not support the 'arity
; property, and procedure-property just returns false.  In
; this case, we assume that the procedure returns 1 argument,
; as this is the most useful default for our purposes.  Sigh.

(define (procedure-num-args p) 
  (let ((arity (procedure-property p 'arity)))
    (if arity (car arity) 1)))

; ****************************************************************

; Set print-ok? to whether or not we are the MPI master process.
; Also, MPI doesn't support interactive mode.  However, don't try this
; if we are running within gen-ctl-io, as it won't work.
(if (not (defined? 'output-source)) ; (a function defined by gen-ctl-io)
    (begin
      (set-param! print-ok? (zero? (meep-my-rank)))
      (set-param! interactive? (= 1 (meep-count-processors)))))

; ****************************************************************

(define-class material-type no-parent)

(define-class polarizability no-parent
  (define-property omega no-default 'number)
  (define-property gamma no-default 'number)
  (define-property delta-epsilon no-default 'number)
  (define-property sigma 1.0 'number)
  (define-property energy-saturation 0.0 'number))

(define-class medium material-type
  (define-property epsilon no-default 'number)
  (define-property polarizations '() (make-list-type 'polarizability))
  (define-property chi2 0 'number)
  (define-property chi3 0 'number)
  (define-property mu 1 'number)
  (define-property D-conductivity-diag (vector3 0 0 0) 'vector3)
  (define-property B-conductivity-diag (vector3 0 0 0) 'vector3)
)

(define dielectric medium) ; old name for backwards compatibility

; useful shortcuts for isotropic conductivity
(define (D-conductivity c) (D-conductivity-diag c c c))
(define (B-conductivity c) (B-conductivity-diag c c c))

(define-class perfect-metal material-type)

; arbitrary material(x)
(define-class material-function material-type
  (define-property material-func no-default 'function
    (lambda (p) (= 1 (procedure-num-args p)))))
(define (epsilon-func f) ; convenience wrapper
  (material-func (lambda (p) (make dielectric (epsilon (f p))))))

(define (index n) (epsilon (* n n))) ; convenient substitute for epsilon

; use the solid geometry classes, variables, etcetera in libgeom:
; (one specifications file can include another specifications file)
(include "@LIBCTL_DIR@/utils/geom.scm")

(if (defined? 'meep-component-Ex) (include "meep-enums.scm"))

(define CYLINDRICAL -2) ; special value of dimensions for cylindrical coords

; ****************************************************************
; Add some predefined variables, for convenience:

(define vacuum (make dielectric (epsilon 1.0)))
(define air vacuum)
(define metal (make perfect-metal))

(define infinity 1.0e20) ; big number for infinite dimensions of objects

(set! default-material vacuum)

(define pi (* 4.0 (atan 1.0)))

; ****************************************************************
; some utilities

(define infinity 1.0e20) ; big number for infinite dimensions of objects

; round x to dig digits after the decimal place
(define (round-dig dig x) (/ (round (* x (expt 10 dig))) (expt 10 dig)))

; display a comma-delimited list of values, prefixed by the data-name
; and the run index, with data a list of values.
(define-param run-index 0)
(define (display-run-data data-name data)
  (print data-name run-index ":")
  (map (lambda (v) (print ", " v)) data)
  (print "\n"))

; display a list of data arrays (all required to be of same length)
; as comma-separated values, prefixed with name (and the run index).
(define (display-csv name . ds)
  (if (not (null? ds))
      (apply
       map
       (cons 
	(lambda (. vs) (display-run-data name vs))
	ds))))

; ****************************************************************
; More input variables

(define structure '())

; list of sources added by init-fields (below)
(define-param sources '())

(define-param m 0)
(define-param force-complex-fields? false)

(define-param k-point false)

(define fields '())

(define-param subpixel-tol 1e-4)
(define-param subpixel-maxeval 100000)

(define-param store-polarization-energy? false)

; ****************************************************************
; Setting up the structure

(define-class symmetry no-parent
  (define-property direction no-default 'integer)
  (define-property phase 1.0 'cnumber))
(define-class rotate2-sym symmetry)
(define-class rotate4-sym symmetry)
(define-class mirror-sym symmetry)

(define ALL -1) ; special value for directions, when all values
(define-class pml no-parent
  (define-property thickness no-default 'number)
  (define-property direction ALL 'integer)
  (define-property side ALL 'integer)
  (define-property strength 1.0 'number))

(export-type (make-list-type 'symmetry))
(export-type (make-list-type 'pml))

(define-param symmetries '())
(define-param pml-layers '())
(define-param num-chunks 0)
(define-param Courant 0.5)

(define (infer-dimensions k)
  (if (and (not (null? k)) (= dimensions 3)) ; infer dimensions            
      (if (and (= (vector3-z (object-property-value geometry-lattice 'size)) 
		  no-size)
	       (or (not k) (zero? (vector3-z k))))
	  2
	  3)
      dimensions))
(define (require-dimensions!)
  (if (null? structure) (set-dimensions (infer-dimensions k-point))))

(define-class volume-class no-parent
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3))

(define (volume . args)
  (require-dimensions!)
  (let ((v (apply make (cons volume-class args))))
    (let ((cen (object-property-value v 'center))
	  (sz (object-property-value v 'size)))
      (new-meep-geometric-volume 
       (vector3- cen (vector3-scale 0.5 sz))
       (vector3+ cen (vector3-scale 0.5 sz))))))

(define-param eps-averaging? true) ; 10% slower, but huge accuracy gains

(define (init-structure . k_)
  (let ((k (if (null? k_) '() (car k_)))
	(s (object-property-value geometry-lattice 'size)))
    (set! structure (make-structure 
		     (infer-dimensions k)
		     s geometry-center
		     resolution
		     eps-averaging? subpixel-tol subpixel-maxeval
		     (and ensure-periodicity (not (not k)))
		     geometry default-material
		     pml-layers symmetries num-chunks Courant))))

; ****************************************************************
; Adding sources

(define-class src-time no-parent
  (define-property is-integrated? true 'boolean))
(define-class continuous-src src-time
  (define-property frequency no-default 'number)
  (define-property start-time 0 'number)
  (define-property end-time infinity 'number)
  (define-property width 0 'number)
  (define-property cutoff 3.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (let ((s (new-meep-continuous-src-time 
		(* 1.0 (object-property-value o 'frequency))
		(object-property-value o 'width)
		(object-property-value o 'start-time)
		(object-property-value o 'end-time)
		(object-property-value o 'cutoff))))
	(meep-src-time-is-integrated-set s (object-property-value o 'is-integrated?))
	s))))
(define-class gaussian-src src-time
  (define-property frequency no-default 'number)
  (define-property width no-default 'number)
  (define-property start-time 0 'number)
  (define-property cutoff 5.0 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (let ((s (new-meep-gaussian-src-time
		(* 1.0 (object-property-value o 'frequency))
		(object-property-value o 'width)
		(object-property-value o 'start-time)
		(+ (object-property-value o 'start-time)
		   (* 2 (object-property-value o 'width) 
		      (object-property-value o 'cutoff))))))
	(meep-src-time-is-integrated-set s (object-property-value o 'is-integrated?))
	s))))
(define-class custom-src src-time
  (define-property src-func no-default 'function)
  (define-property start-time (- infinity) 'number)
  (define-property end-time infinity 'number)
  (define-derived-property swigval 'SCM
    (lambda (o) 
      (let ((s (new-meep-custom-src-time 
		(object-property-value o 'src-func)
		(object-property-value o 'start-time)
		(object-property-value o 'end-time))))
	(meep-src-time-is-integrated-set s (object-property-value o 'is-integrated?))
	s))))

(define (fwidth df) (width (/ df))) ; to specify frequency width instead
(define (wavelength lam) (frequency (/ lam)))
(define (period T) (frequency (/ T)))

(define-class source no-parent
  (define-property src no-default 'src-time)
  (define-property component no-default 'integer)
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property amplitude 1.0 'cnumber)
  (define-property amp-func '() 'SCM))

(define (add-source s f) ; add source s to fields f
  (let ((A (object-property-value s 'amp-func))
	(cen (object-property-value s 'center))
	(sz (object-property-value s 'size)))
    (if (null? A)
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (object-property-value (object-property-value s 'src) 'swigval)
	 (volume (center cen) (size sz))
	 (* 1.0 (object-property-value s 'amplitude)))
	(meep-fields-add-volume-source
	 fields
	 (object-property-value s 'component)
	 (object-property-value (object-property-value s 'src) 'swigval)
	 (volume (center cen) (size sz))
	 A (* 1.0 (object-property-value s 'amplitude))))))

; ****************************************************************
; Setting up the fields

(define init-fields-hooks '()) ; list of thunks to execute after init-fields
(define (init-fields)
  (if (null? structure) (init-structure k-point))
  (set! fields (new-meep-fields structure 
				(if (= dimensions CYLINDRICAL) m 0)
				store-polarization-energy?))
  (if verbose? (meep-fields-verbose fields))
  (if (not (or force-complex-fields?
	       (and (= dimensions CYLINDRICAL) (not (zero? m)))
	       (not (for-all? symmetries
			      (lambda (s)
				(zero? (imag-part 
					(object-property-value s 'phase))))))
	       (not (or (not k-point) (vector3= k-point (vector3 0))))))
      (meep-fields-use-real-fields fields))
  (if k-point (meep-fields-use-bloch fields k-point))
  (map (lambda (s) (add-source s fields)) sources)
  (map (lambda (thunk) (thunk)) init-fields-hooks))

(define (meep-time) 
  (if (null? fields) (init-fields)) 
  (meep-fields-time fields))

(define (get-field-point c pt)
  (meep-fields-get-field fields c pt))

(define (get-epsilon-point pt)
  (meep-fields-get-eps fields pt))

; ****************************************************************
; Various ways to restart all or part of the simulation.

(define (change-k-point! k)
  (set! k-point k)
  (if (not (null? fields))
      (if (and (not (or (not k-point) (vector3= k-point (vector3 0))))
	       (not (zero? (meep-fields-is-real-get fields))))
	  (begin (delete-meep-fields fields) 
		 (set! fields '())
		 (init-fields))
	  (if k-point (meep-fields-use-bloch fields k-point)))))

(define (change-sources! new-sources)
  (set! sources new-sources)
  (if (not (null? fields))
      (begin
	(meep-fields-remove-sources fields)
	(map (lambda (s) (add-source s fields)) sources))))

(define (reset-meep)
  (delete-meep-fields fields) (set! fields '())
  (delete-meep-structure structure) (set! structure '()))

(define (restart-fields)
  (if (not (null? fields))
      (begin
	(meep-fields-t-set fields 0)
	(meep-fields-zero-fields fields))
      (init-fields)))

; ****************************************************************
; Flux spectra

(define AUTOMATIC -1) ; special value for directions, when auto-determined
(define-class flux-region no-parent
  (define-property center no-default 'vector3)
  (define-property size (vector3 0 0 0) 'vector3)
  (define-property direction AUTOMATIC 'integer)
  (define-property weight 1.0 'cnumber))

(define (fields-add-flux fields fcen df nfreq . fluxes)
  (define gvl '()) ; geometric_volume_list of flux regions
  (map (lambda (f)
	 (let* ((gv (volume (center (object-property-value f 'center))
			    (size (object-property-value f 'size))))
		(d0 (object-property-value f 'direction))
		(d (if (negative? d0)
		       (meep-fields-normal-direction fields gv)
		       d0))
		(c (meep-direction-component Sx d)))
	   (set! gvl
		 (make-geometric-volume-list
		  (volume (center (object-property-value f 'center))
			  (size (object-property-value f 'size)))
		  c
		  (object-property-value f 'weight)
		  gvl))))
       fluxes)
  (let ((flux
	 (meep-fields-add-dft-flux fields gvl 
				   (- fcen (/ df 2)) (+ fcen (/ df 2)) nfreq)))
    (delete-meep-geometric-volume-list gvl)
    flux))

(define (add-flux fcen df nfreq . fluxes)
  (if (null? fields) (init-fields))
  (apply fields-add-flux (append (list fields fcen df nfreq) fluxes)))

(define (scale-flux-fields s f)
  (meep-dft-flux-scale-dfts f s))

(define (get-flux-freqs f)
  (arith-sequence
   (meep-dft-flux-freq-min-get f)
   (meep-dft-flux-dfreq-get f)
   (meep-dft-flux-Nfreq-get f)))

(export-type (make-list-type 'number))
(define (get-fluxes f)
  (dft-flux-flux f))

(define (display-fluxes . fluxes)
  (if (not (null? fluxes))
      (apply display-csv
	     (append (list "flux"
			   (get-flux-freqs (car fluxes)))
		     (map get-fluxes fluxes)))))

(define (load-flux fname flux)
  (if (null? fields) (init-fields))
  (meep-dft-flux-load-hdf5 flux fields fname "" (get-filename-prefix)))

(define (save-flux fname flux)
  (if (null? fields) (init-fields))
  (meep-dft-flux-save-hdf5 flux fields fname "" (get-filename-prefix)))

(define (load-minus-flux fname flux)
  (load-flux fname flux)
  (meep-dft-flux-scale-dfts flux -1.0))

; ****************************************************************
; Generic step functions: these are functions which are called
; (potentially) at every time step.  They can either be a thunk
; or they can take one argument, to-do.  to-do is either 'step
; or 'finish, where 'step means to output (or whatever)
; normally, and 'finish is passed once at the end of the run
; (and is used to close files, print summary output, etcetera).

; step functions can be either thunks (the common case), or
; can take a "to-do" argument that is currently either 'step
; or 'finish (so that they can clean up at the end of a run).
(define (eval-step-func func to-do)
  (if (= 0 (procedure-num-args func))
      (if (eq? to-do 'step) (func))
      (func to-do)))
 
; Some convenient wrappers for step functions passed to run.  e.g., these
; can be used to only output at certain times, instead of ata every time step.

(define (combine-step-funcs . step-funcs)
  (lambda (to-do)
    (map (lambda (f) (eval-step-func f to-do)) step-funcs)))

; generic wrapper
(define (when-true-funcs cond? step-funcs)
  (lambda (to-do)
    (if (or (eq? to-do 'finish) (cond?))
	(map (lambda (f) (eval-step-func f to-do)) step-funcs))))

; evaluate step-funcs whenever (cond?) is true/false.
(define (when-true cond? . step-funcs) (when-true-funcs cond? step-funcs))
(define (when-false cond? . step-funcs) 
  (when-true-funcs (lambda () (not (cond?))) step-funcs))

; output at an interval of dT (in meep/simulation time).
(define (at-every dT . step-funcs)
  (if (null? fields) (init-fields))
  (let ((Tlast (meep-time)))
    (lambda (to-do)
      (let ((T (meep-time)))
	(if (or (eq? to-do 'finish) 
		(>= T (+ Tlast dT (* -0.5 (meep-fields-dt-get fields)))))
	    (begin
	      (map (lambda (f) (eval-step-func f to-do)) step-funcs)
	      (set! Tlast T)))))))

(define (after-time T . step-funcs)
  (if (null? fields) (init-fields))
  (let ((T0 (meep-time)))
    (when-true-funcs (lambda () (>= (meep-time) (+ T0 T))) step-funcs)))

(define (before-time T . step-funcs)
  (if (null? fields) (init-fields))
  (let ((T0 (meep-time)))
    (when-true-funcs (lambda () (< (meep-time) (+ T0 T))) step-funcs)))

(define (at-time T . step-funcs)
  (let ((done? false))
    (after-time T (lambda (to-do)
		    (if (or (not done?) (eq? to-do 'finish))
			(map (lambda (f) (eval-step-func f to-do)) step-funcs))
		    (set! done? (or done? (eq? to-do 'step)))))))

(define (after-sources . step-funcs)
  (if (null? fields) (init-fields))
  (apply after-time
	 (cons (- (meep-fields-last-source-time fields) (meep-time))
	       step-funcs)))

; after sources plus a time T.
(define (after-sources+ T . step-funcs)
  (if (null? fields) (init-fields))
  (apply after-time
	 (cons (- (+ (meep-fields-last-source-time fields) T) (meep-time))
	       step-funcs)))

(define (during-sources . step-funcs)
  (if (null? fields) (init-fields))
  (apply before-time
	 (cons (- (meep-fields-last-source-time fields) (meep-time))
	       step-funcs)))

; the user could just call functions, but this functions saves the user
; from having to manually call init-fields
(define (at-beginning . step-funcs)
  (let ((done? false))
    (lambda (to-do)
      (if (not done?)
	  (begin
	    (map (lambda (f) (eval-step-func f to-do)) step-funcs)
	    (set! done? true))))))

; for completeness (although the user could just do this after running):
(define (at-end . step-funcs)
  (lambda (to-do)
    (if (eq? to-do 'finish)
	(begin
	  (map (lambda (f) (eval-step-func f 'step)) step-funcs)
	  (map (lambda (f) (eval-step-func f 'finish)) step-funcs)))))

; ****************************************************************
; File output functions (can only be called after init-fields).

(define-param filename-prefix "")
(define (get-filename-prefix)
  (if (eq? filename-prefix false)
      ""
      (if (and (not (null? include-files))
	       (string-null? filename-prefix))
	  (string-append
	   (strip-suffix ".scm"
	     (strip-suffix ".ctl" (cdr (split-pathname (car include-files))))))
	  filename-prefix)))

; Use output directory instead of outputting in same directory;
; uses init-fields-hooks to handle fields not yet initted.
(define (use-output-directory . dname_)
  (let ((dname (if (null? dname_)
		   (string-append (get-filename-prefix) "-out")
		   (car dname_))))
    (let ((hook
	   (let ((trashed? false)) ; only trash output directory once per run
	     (lambda ()
	       (print "Meep: using output directory \"" dname "\"\n")
	       (meep-fields-set-output-directory fields dname)
	       (if (not trashed?) (meep-trash-output-directory dname))
	       (set! trashed? true)))))
      (set! init-fields-hooks (cons hook init-fields-hooks))
      (if (not (null? fields)) (hook))
      (set! filename-prefix false)
      dname)))

(define-param output-volume '()) ; region to output; NULL for everywhere

(define output-append-h5 '()) ; h5 file to append data to (NULL if none)

; hook function called with the filename after every HDF5 files is created;
; this can be used to convert the file into other formats, etcetera.
(define output-h5-hook (lambda (fname) false)) ; default is no-op

(define output-single-precision? false) ; output single-prec to save space

(define meep-last-eps-filename "") ; most recent epsilon file outputted

(define (output-component c . h5file)
  (if (null? fields) (error "init-fields is required before output-component"))
  (meep-fields-output-hdf5 
   fields c 
   (if (null? output-volume)
       (meep-fields-total-volume fields)
       output-volume)
   (if (null? h5file) output-append-h5 (car h5file)) 
   (and (null? h5file) (not (null? output-append-h5)))
   output-single-precision? 
   (get-filename-prefix))
  (if (null? h5file)
      (let ((nm (meep-fields-h5file-name fields (meep-component-name c)
					 (get-filename-prefix) true)))
	(if (eq? c Dielectric) (set! meep-last-eps-filename nm))
	(output-h5-hook nm))))

; cs = list of components, and func is function of position & these components
(define (output-field-function-helper name cs func real-only? h5file)
  (if (null? fields) (error "init-fields is required before output-field-function"))
  (meep-fields-output-hdf5
   fields name
   (cons cs func)
   (if (null? output-volume)
       (meep-fields-total-volume fields)
       output-volume)
   (if (null? h5file) output-append-h5 (car h5file))
   (and (null? h5file) (not (null? output-append-h5)))
   output-single-precision?
   (get-filename-prefix)
   real-only?)
  (if (null? h5file)
      (output-h5-hook (meep-fields-h5file-name fields
                       name (get-filename-prefix) true))))

(define (output-field-function name cs func . h5file)
  (output-field-function-helper name cs func false h5file))

(define (output-real-field-function name cs func . h5file)
  (output-field-function-helper name cs func true h5file))

(define (output-components fname . cs)
  (if (null? fields) (error "init-fields is required before output-component"))
  (let ((f 
	 (if (null? output-append-h5)
	     (list (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
					    (get-filename-prefix) true))
	     '())))
    (map (lambda (c) 
	   (apply output-component (cons c f))
	   (if (null? output-append-h5) 
	       (meep-h5file-prevent-deadlock (car f))))
	 cs)
    (if (null? output-append-h5) (delete-meep-h5file (car f))))
  (if (null? output-append-h5)
      (output-h5-hook (meep-fields-h5file-name 
		       fields fname (get-filename-prefix) true))))

; convenience functions, similar to MPB:
(define (output-epsilon) (output-component Dielectric))
(define (output-mu) (output-component Permeability))
(define (output-hpwr) (output-component H-EnergyDensity))
(define (output-dpwr) (output-component D-EnergyDensity))
(define (output-tot-pwr) (output-component EnergyDensity))
(defmacro-public define-output-field (name cp CP)
  `(begin
     (define (,(symbol-append 'output- cp))
       (output-components ,name
			  ,(symbol-append CP 'x)
			  ,(symbol-append CP 'y)
			  ,(symbol-append CP 'z)
			  ,(symbol-append CP 'r) ,(symbol-append CP 'p)))
     (define (,(symbol-append 'output- cp '-x))
       (output-component ,(symbol-append CP 'x)))
     (define (,(symbol-append 'output- cp '-y))
       (output-component ,(symbol-append CP 'y)))
     (define (,(symbol-append 'output- cp '-z))
       (output-component ,(symbol-append CP 'z)))
     (define (,(symbol-append 'output- cp '-r))
       (output-component ,(symbol-append CP 'r)))
     (define (,(symbol-append 'output- cp '-p))
       (output-component ,(symbol-append CP 'p)))))
(define-output-field "h" hfield H)
(define-output-field "e" efield E)
(define-output-field "d" dfield D)
(define-output-field "s" poynting S) ; compat. with MPB.
(define-output-field "s" sfield S)

(define (with-prefix pre . step-funcs)
  (lambda (to-do)
    (let ((pre-save filename-prefix))
      (set! filename-prefix (string-append pre (get-filename-prefix)))
      (map (lambda (f) (eval-step-func f to-do)) step-funcs)
      (set! filename-prefix pre-save))))

; change output-volume for a few step-funcs to gv
(define (in-volume gv . step-funcs)
  (let ((cur-eps "")) ; allow per-volume eps filenames
    (lambda (to-do)
      (let ((gv-save output-volume)
	    (eps-save meep-last-eps-filename))
	(set! output-volume gv)
	(if (not (string-null? cur-eps))
	    (set! meep-last-eps-filename cur-eps))
	(map (lambda (f) (eval-step-func f to-do)) step-funcs)
	(set! cur-eps meep-last-eps-filename)
	(set! output-volume gv-save)
	(if (not (string-null? eps-save))
	    (set! meep-last-eps-filename eps-save))))))
(define (in-point pt . step-funcs)
  (apply in-volume (cons (volume (center pt)) step-funcs)))

; Meep supports outputting d+1 dimensional HDF5 files where the last
; dimension is time.
(define (to-appended fname . step-funcs)
  (if (null? fields) (init-fields))
  (let ((h5 (meep-fields-open-h5file fields fname (meep-h5file-WRITE)
				     (get-filename-prefix))))
    (lambda (to-do)
      (let ((h5save output-append-h5))
	(set! output-append-h5 h5)
	(map (lambda (f) (eval-step-func f to-do)) step-funcs)
	(if (eq? to-do 'finish) 
	    (begin 
	      (delete-meep-h5file h5)
	      (output-h5-hook (meep-fields-h5file-name
			       fields fname (get-filename-prefix)))))
	(set! output-append-h5 h5save)))))

(define (convert-h5 rm? convert-cmd . step-funcs)
  (define (convert fname)
    (if (zero? (meep-my-rank))
	(if (and (zero? (system (string-append convert-cmd " \"" fname "\"")))
		 rm?)
	    (system (string-append "rm \"" fname "\"")))))
  (lambda (to-do)
    (let ((hooksave output-h5-hook))
      (set! output-h5-hook convert)
      (map (lambda (f) (eval-step-func f to-do)) step-funcs)
      (set! output-h5-hook hooksave))))

(define (h5topng rm? options . step-funcs)
  (apply convert-h5 (cons rm? (cons (string-append 
				     "EPS=\"" meep-last-eps-filename "\"; "
				     "h5topng " options) 
				    step-funcs))))

(define (output-png-rm? rm? c options)
  (let ((maxabs 0.0)) ; keep track of amplitude for image scaling
    (lambda (to-do)
      (if (eq? to-do 'step)
	  (begin
	    (set! maxabs 
		  (max maxabs
		       (meep-fields-max-abs 
			fields c
			(if (null? output-volume)
			    (meep-fields-total-volume fields)
			    output-volume))))
	    ((h5topng rm? 
		      (string-append "-M " (number->string maxabs) " " options)
		      (lambda () (output-component c))) to-do))))))

(define (output-png c options) (output-png-rm? true c options))
(define (output-png+h5 c options) (output-png-rm? false c options))

; ****************************************************************
; harminv functions for extracting bands, etcetera

 ; for do-harminv
(export-type (make-list-type 'cnumber))
(export-type (make-list-type 'cvector3))

; generic data-collection function
(defmacro-public collect-harminv! (data data-dt)
  `(lambda (c pt)
     (set! ,data '())
     (let ((t0 0))
       (lambda () 
	 (set! ,data-dt (- (meep-time) t0))
	 (set! t0 (meep-time))
	 (set! ,data (cons (get-field-point c pt) ,data))))))

; do-harminv returns a (freq, amp, err) vector3; define accessor functions:
(define harminv-freq vector3-x)
(define (harminv-freq-re b) (real-part (vector3-x b)))
(define (harminv-freq-im b) (imag-part (vector3-x b)))
(define (harminv-Q b) (/ (harminv-freq-re b)
			 (* -2 (harminv-freq-im b))))
(define harminv-amp vector3-y)
(define harminv-err vector3-z)

(define (analyze-harminv data fcen df maxbands . dt)
  (display-run-data 
   "harminv"
   (list "frequency" "imag. freq." "Q" "|amp|" "amplitude" "error"))
  (let ((bands (do-harminv data
			   (if (null? dt)
			       (meep-fields-dt-get fields)
			       (car dt))
			   (- fcen (/ df 2)) (+ fcen (/ df 2)) maxbands)))
    (map (lambda (b) ; b = vector of (freq, amp, error)
	   (display-run-data 
	    "harminv"
	    (list
	     (harminv-freq-re b)
	     (harminv-freq-im b)
	     (harminv-Q b)
	     (magnitude (harminv-amp b))
	     (harminv-amp b)
	     (harminv-err b))))
	 bands)
    bands))

(defmacro-public harminv! (data dt results c pt fcen df maxbands)
  `(let ((data' '()) (dt' 0)
	 (c' ,c) (pt' ,pt) (fcen' ,fcen) (df' ,df) (maxbands' ,maxbands))
     (combine-step-funcs
      (at-end
       (lambda ()
	 (set! ,data (reverse data')) ; put in correct order
	 (set! ,dt dt')
	 (set! ,results 
	       (analyze-harminv ,data fcen' df'
				(if (list? maxbands')
				    (if (null? maxbands') 100 (car maxbands'))
				    (if (zero? maxbands') 100 maxbands'))
				dt'))))
      ((collect-harminv! data' dt') c' pt'))))

; collect in harminv-data + analyze and store in harminv-results
(define harminv-data '())
(define harminv-data-dt 0)
(define harminv-results '())
(define (harminv c pt fcen df . mxbands)
  (harminv! harminv-data harminv-data-dt harminv-results c pt fcen df mxbands))

; ****************************************************************
; run functions

; default time interval (seconds) between progress printouts
(define-param progress-interval 4)

; display progress from T0 until T, every dt seconds (wall time)
(define (display-progress T0 T dt)
  (let ((t0 (meep-wall-time)) (tlast (meep-wall-time)))
    (lambda ()
      (let ((t (meep-wall-time)))
	(if (>= (- t tlast) dt)
	    (begin
	      (print "Meep progress: " 
		     (- (meep-time) T0) "/" T " = "
		     (round-dig 1 (/ (- (meep-time) T0) (* 0.01 T))) "% done"
		     " in " (round-dig 1 (- t t0)) "s, " 
		     (round-dig 1 ( - (* (- t t0) (/ T (- (meep-time) T0)))
				      (- t t0))) "s to go\n")
	      (set! tlast t)))))))

; run until (cond?) is true or, if cond? is a number, until time cond?
; (in Meep units) has elapsed, calling step-funcs at every time step.
(define (run-until cond? . step-funcs)
  (set! interactive? false)
  (if (null? fields) (init-fields))
  (if (number? cond?) ; cond? is a time to run for
      (let ((T0 (meep-time))) ; current Meep time
	(apply run-until (cons (lambda () (>= (meep-time) 
					      (+ T0 cond?)))
			       (cons (display-progress T0 (+ T0 cond?) 
						       progress-interval)
				     step-funcs))))
      (begin ; otherwise, cond? is a boolean thunk
	(map (lambda (f) (eval-step-func f 'step)) step-funcs)
	(if (cond?)
	    (begin
	      (map (lambda (f) (eval-step-func f 'finish)) step-funcs)
	      (print "run " run-index " finished at t = " (meep-time)
		     " (" (meep-fields-t-get fields) " timesteps)\n")
	      (set! run-index (+ run-index 1)))
	    (begin
	      (meep-fields-step fields)
	      (apply run-until (cons cond? step-funcs)))))))

; run until all sources are finished and cond? is true.  If cond? is a number
; T, run until all sources are finished + a time T.
(define (run-sources+ cond? . step-funcs)
  (if (null? fields) (init-fields))
  (let ((Ts (meep-fields-last-source-time fields)))
  (apply run-until 
	 (cons (if (number? cond?)
		   (+ (- Ts (meep-time)) cond?)
		   (lambda () (and (cond?) (>= (meep-time) Ts))))
	       step-funcs))))

; run until all sources are finished
(define (run-sources . step-funcs)
  (apply run-sources+ (cons 0 step-funcs)))

; condition function, designed to be used in conjunction with run-sources+,
; that returns true when |field|^2 at a given point has decayed more than
; a certain amount, always running for at least steps of dT.
(define (stop-when-fields-decayed dT c pt decay-by)
  (if (null? fields) (init-fields))
  (let ((T0 (meep-time))
	(max-abs (sqr (magnitude (meep-fields-get-field fields c pt))))
	(cur-max 0))
    (lambda ()
      (let ((fabs (sqr (magnitude (meep-fields-get-field fields c pt)))))
	(set! cur-max (max cur-max fabs))
	(if (<= (meep-time) (+ T0 dT))
	    false ; don't stop yet
	    (let ((old-cur cur-max))
	      (set! cur-max 0)
	      (set! T0 (meep-time))
	      (set! max-abs (max max-abs old-cur))
	      (if (not (zero? max-abs))
		  (print "field decay(t = " (meep-time)"): "
			 old-cur " / " max-abs " = " (/ old-cur max-abs) "\n"))
	      (<= old-cur (* max-abs decay-by))))))))
	    

; ****************************************************************
; band diagrams

(define (run-k-point T k)
  (define cs (map (lambda (o) (object-property-value o 'component)) sources))
  (define pts (map (lambda (o) (object-property-value o 'center)) sources))
  (define As (map (lambda (o) (object-property-value o 'amplitude)) sources))
  (define fmin 
    (max 0 (apply min (map (lambda (o)
			     (let ((t (object-property-value o 'src)))
			       (if (object-member? 'gaussian-src t)
				   (- (object-property-value t 'frequency)
				      (/ 1 (object-property-value t 'width) 2))
				   infinity)))
			   sources))))
  (define fmax 
    (apply max (map (lambda (o)
		      (let ((t (object-property-value o 'src)))
			(if (object-member? 'gaussian-src t)
			    (+ (object-property-value t 'frequency)
			       (/ 1 (object-property-value t 'width) 2))
			    0)))
		    sources)))
  (if (or (null? cs) (> fmin fmax))
      (error "run-k-point requires a gaussian-src source"))
  ; TODO: apply harminv to multiple points and only accept freqs
  ; with correct relative amplitudes?
  (change-k-point! k)
  (restart-fields)
  (run-sources+ T (after-sources 
		   (harminv (car cs) (car pts) 
			    (* 0.5 (+ fmin fmax)) (- fmax fmin))))
  (map harminv-freq harminv-results))

(define (run-k-points T k-points)
  (define k-index 0)
  (define all-freqs '())
  (map (lambda (k)
	 (set! k-index (+ k-index 1))
	 (if (= k-index 1) (begin (init-fields) (output-epsilon)))
	 (let ((freqs (run-k-point T k)))
	   (print "freqs:, " k-index 
		  ", " (vector3-x k) ", " (vector3-y k) ", " (vector3-z k))
	   (map (lambda (x) (print ", " x)) (map real-part freqs)) 
	   (print "\n")
	   (print "freqs-im:, " k-index 
		  ", " (vector3-x k) ", " (vector3-y k) ", " (vector3-z k))
	   (map (lambda (x) (print ", " x)) (map imag-part freqs))
	   (print "\n")
	   (set! all-freqs (cons freqs all-freqs))))
       k-points)
  (reverse all-freqs))


; ****************************************************************
; field integration

(define (get-where-and-fields where-and-fields)
  (let ((f (if (= 2 (length where-and-fields))
	       (cadr where-and-fields)
	       fields)))
    (if (null? f)
	(error "init-fields is required before using field functions"))
    (let ((where (if (null? where-and-fields)
		     (meep-fields-total-volume f)
		     (car where-and-fields))))
      (cons where f))))

(define (integrate-field-function cs func . where-and-fields)
  (let ((waf (get-where-and-fields where-and-fields)))
    (meep-fields-integrate (cdr waf) (cons cs func) (car waf))))

(define (max-abs-field-function cs func . where-and-fields)
  (let ((waf (get-where-and-fields where-and-fields)))
    (meep-fields-max-abs (cdr waf) (cons cs func) (car waf))))

(define (flux-in-box dir box)
  (if (null? fields)
      (error "init-fields is required before using flux-in-box"))
  (meep-fields-flux-in-box fields dir box))
(define (electric-energy-in-box box)
  (if (null? fields)
      (error "init-fields is required before using electric-energy-in-box"))
  (meep-fields-electric-energy-in-box fields box))
(define (magnetic-energy-in-box box)
  (if (null? fields)
      (error "init-fields is required before using magnetic-energy-in-box"))
  (meep-fields-magnetic-energy-in-box fields box))
(define (field-energy-in-box box)
  (if (null? fields)
      (error "init-fields is required before using field-energy-in-box"))
  (meep-fields-field-energy-in-box fields box))

; ****************************************************************

; Load GNU Readline support, for easier command-line editing support.
; This is not loaded in by default in Guile 1.3.2+ because readline is
; licensed under the GPL, which would have caused Guile to effectively
; be under the GPL itself.  However, since Meep is under the GPL too,
; we can load Readline by default with no problems.

@ACTIVATE_READLINE@  ; command to activate readline is determined by configure

(set! scm-repl-prompt "meep> ")

; ****************************************************************
