\begin{comment}
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

#include "dactyl.h"
\end{comment}

\section{Epsilon of a polaritonic material in one dimension}

In this example, we compute epsilon as a function of frequency for a simple
polaritonic material.  This example is done in one dimension for speed
purposes.

One thing to be aware of when using polaritonic materials, is that
generally you will be needing a rather higher grid resolution than you may
be used to in order to properly model the material.  Here I am using an $a$
of just 20, and if you look at figure~\ref{epsilon_polariton}, you can see
that the curve deviates significantly from the predicted result, which
would be essentially symmetric around the resonant frequency of $0.4$.

\begin{figure}
\label{epsilon_polariton}
\caption{Epsilon of a polaritonic material.}
\epsfig{file=epsilon_polariton_1d-out/eps.eps,width=8.8cm}
\end{figure}


\begin{comment}
const double rmax  = 2.0;
const double a = 20;
const double pml_thickness = 2.0;
const double zsize = 4/a + 2*pml_thickness;
\end{verbatim}

For our example polaritonic material, we'll use an $\epsilon(0)$ of 13.4.

\begin{verbatim}
double eps(const vec &) { return 13.4; }
\end{verbatim}
\begin{comment}
double one(const vec &) { return 1; }

int main(int argc, char **argv) {
  deal_with_ctrl_c();
  const double ttot = 600.0;
  mat ma(volone(zsize, a), eps);
  const char *dirname = make_output_directory(argv[0]);
  printf("Storing output in directory %s/\n", dirname);
  ma.set_output_directory(dirname);
\end{comment}
Notice that the polaritonic material will be within the PML.  This is fine.
Polaritons and PML are friends.
\begin{verbatim}
  ma.use_pml_right(pml_thickness);
  ma.use_pml_left(pml_thickness);
  ma.add_polarizability(one, 0.4, 0.01, 27.63);
\end{verbatim}
\begin{comment}
  fields f(&ma);
  double sourceloc = pml_thickness+1.0/(double)a;
\end{comment}
We use a single rather high frequency (and very broad) plane wave source,
to cover a broad frequency range.  For a plane source in 1D we don't really
need a source profile.
\begin{verbatim}
  f.add_plane_source(0.9 , 0.8, 0.0, 8.0, one, vec(sourceloc));
\end{verbatim}
We use a couple of monitor points to determine epsilon.
\begin{verbatim}
  monitor_point *left = NULL, *right = NULL;
\end{verbatim}
\begin{comment}
  double next_printtime = 50;
  while (f.time() < ttot && !interrupt) {
    if (f.time() >= next_printtime) {
      next_printtime += 50;
      printf("Working on time %lg...  ", f.time());
      printf("energy is %lg\n", f.field_energy());
    }
\end{comment}
The monitor points are located one grid spacing from one another.  The
\verb*|get_new_point| method appends the fields at a given time to a
monitor point linked list.
\begin{verbatim}
    left  = f.get_new_point(vec(sourceloc+1.0/a), left );
    right = f.get_new_point(vec(sourceloc+2.0/a), right);
\end{verbatim}
\begin{comment}
    f.step();
  }
  grace g("eps", dirname);
  complex<double> *al, *ar, *freqs;
  int numl, numr;
  printf("Working on left fourier transform...\n");
\end{comment}
When the time stepping is over, we take a fourier transform of the fields
at the two monitor points.
\begin{verbatim}
  left->fourier_transform(Ex, &al, &freqs, &numl, 0.301, 0.5, 1000);
\end{verbatim}
\begin{comment}
  delete[] freqs;
  printf("Working on right fourier transform...\n");
  right->fourier_transform(Ex, &ar, &freqs, &numr, 0.301, 0.5, 1000);
  if (numl != numr) printf("Aaack you need both nums to be the same!\n");
  g.new_set();
  g.set_legend("\\x\\e\\s2\\N");
\end{comment}
Finally we calculate the complex index of refraction using the equation
\begin{equation*}
i \omega \Delta x n(\omega) = \log \left(\frac{E'(\omega)}{E(\omega)}\right)
\end{equation*}
\begin{verbatim}
  for (int i=0;i<numl;i++) {
    complex<double> I = complex<double>(0,1);
    complex<double> n = (log(ar[i]/al[i]))/(I*(1.0/a)*2*pi*freqs[i]);
    g.output_point(real(freqs[i]), real(n*n));
  }
\end{verbatim}
\begin{comment}
  g.new_set();
  g.set_legend("\\x\\e\\s2\\N");
  for (int i=0;i<numl;i++) {
    complex<double> I = complex<double>(0,1);
    complex<double> n = (log(ar[i]/al[i]))/(I*(1.0/a)*2*pi*freqs[i]);
    g.output_point(real(freqs[i]), imag(n*n));
  }
}
\end{comment}

